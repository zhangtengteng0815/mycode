第一章：创建和销毁对象	
	第一条：考虑用静态工厂方法代替构造器
		valueOf
		of
		getInstance
		newInstance
		getType
		newType
	第二条：遇到多个构造器时考虑用构建器
	第三条：用私有构造器或者枚举类型强化singleton属性
	第四条：通过私有构造器强化不可实例化的能力
	第五条：避免创建不必要的对象
		要优先使用基本类型而不是装箱基本类型
	第六条：消除过期的对象引用
		一般而言，只要类是自己管理内存，程序员就应该警惕内存泄漏的问题
		内存泄漏的另一个常见来源是缓存	WeakHashMap
		内存泄漏的第三个常见来源是监听器和其他回调	WeakHashMap
	第七条：避免使用终结方法
		使用终结方法有一个非常严重的性能损失
		显示终止的方法通常与try-finally结构结合起来使用，以确保及时终止
			InputStream OutputStream java.sql.Connection
第二章：对于所有对象的通用方法
	第八条：覆盖equals时请遵守通用约定		
		类的每个实例本质上都是唯一的
		不关心类是否提供了“逻辑相等”的测试功能
		超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的
		类是私有的或者是包级私有的，可以确定它的equals方法永远不会被调用
		实现高质量equals方法的诀窍：
		1.使用==操作符检查“参数是否为这个对象的引用”
		2.使用instanceof操作符检查“参数是否为正确的类型”
		3.把参数转换成正确的类型
		4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域想匹配
		5.当你编写完成了equals方法之后，应该问自己三个问题：它是否是对称的，传递的，一致的
			覆盖equals时总要覆盖hashCode
			不要企图让equals方法过于智能
			不要将equals声明中的object对象替换为其他类型
	第九条：覆盖equals时总要覆盖hashCode
	第十条：始终要覆盖toString
	第十一条：谨慎的覆盖clone
		实际上clone方法就是另一个构造器，你必须确保它不会伤害到原始的对象，并确保正确的创建对象中的约束
		clone架构与引用可变对象的final域的正常用法是不兼容的
	第十二条：考虑实现comparable接口
第三章：类和接口
	第十三条：使类和成员的可访问性最小化
		尽可能使每个类或者成员不被外界访问
		实例域决不能是共有的
	第十四条：在共有类中使用访问方法而非公有域
	第十五条：使可变性最小化
		为了使类成为不可变，要遵循下面五条规则：
		1.不要提供任何会修改对象状态的方法
		2.保证类不会被扩展
		3.使所有的域都是final的
		4.使所有域都是私有的
		5.确保对于任何可变组件的互斥访问
		
		不可变对象本质上是线程安全的，它们不要求同步
		不可变对象的唯一缺点是，对于每个不同的值都需要一个单独的对象
	第十六条：复合优先于继承
	第十七条：要么为继承而设计，并提供文档说明，要么就禁止继承	
	第十八条：接口优于抽象类
		现有的类可以很容易被更新，以实现新的接口
		接口是定义mixin（混合类型）的理想选择
		接口允许我们构造非层次结构的类型框架
	第十九条：接口只用于定义类型
		常量接口模式是对接口的不良使用
		静态导入
		import static *****；
	第二十条：类层次优于标签类
		标签类过于冗长、容易出错，且效率低下
	第二十一条：用函数对象表示策略
		函数指针的主要用途就是实现策略模式（strategy）
	第二十二条：优先考虑静态成员类
		嵌套类有四种：静态成员类、非静态成员类、匿名类和局部类
第四章：泛型
	第二十三条：请不要在新代码中使用原生态类型
		如果使用原生态类型，就失掉了泛型在安全性和表述性方面的所有优势
		如果使用像List这样的原生态类型，就会失掉类型安全性，但是如果使用像List<Object>这样的参数化类型，则不会
		无限制的通配符类型？
		
		在类文字中必须使用原生态类型
		instanceof
		
		Set<Object>是个参数化类型，表示可以包含任何对象类型的一个集合
		Set<?>是一个通配符类型，表示只能包含某种未知对象类型的一个集合
		Set是一个原生态类型，它脱离了泛型系统
		
				术语					示例								所在条目
			      参数化类型			List<String>			  			23
			      实际类型参数    			String					  			23			
			      泛型				List<E>					  			23,26
			      形式化类型参数			E						  			23
			      无限制通配符			List<?>					  			23
			      原生态类型			List					  			23
			      有限制类型参数			<E extends Number> 		  			26
			      递归类型限制			<T extends Comparable<T>> 			27
			      有限制通配符类型		List<? extends Number>	  			28
			      泛型方法				static <E> List<E> asList(E[] a)   	27
			      类型令牌				String.class						29
	第二十四条：消除非受检警告	
		使用泛型编程时，会受到的编译器警告：
			非受检强制转化警告（unchecked cast warning）
			非受检方法调用警告
			非受检普通数组创建警告
			非受检转换警告（unchecked conversion warning）
		如果无法消除警告，同时可以证明引起警告的代码是类型安全的可以用@SuppressWarnings注解来禁止这条警告
		应该始终在尽可能小的范围中国使用SuppressWarnings注解
	第二十五条：列表优于数组
		数组是具体化的，因此数组会在运行时才知道并检查它们的元素类型约束
		泛型是通过擦除来实现的，因此泛型只在编译时强化它们的类型信息，并在运行时擦除它们的元素类型信息
		
		数组和泛型不能很好的混合使用，第一考虑应该是用列表代替数组
	第二十六条：优先考虑泛型
	第二十七条：优先考虑泛型方法
		类型推导
	第二十八条：利用有限制通配符来提升API的灵活性
		为了获得最大限度的灵活性，要在表示生产者或者消费者的输入参数上使用通配符类型
		producer-extends，consumer-super
		<? extends T> <? super T>
		不要用通配符类型作为返回类型
	第二十九条：优先考虑类型安全的异构容器
第五章：枚举和注解
	第三十条：用enum代替int常量
		枚举类型为类型安全的枚举模式
	第三十一条：用实例域代替序数
		每个枚举都有一个ordinal方法，返回每个枚举在类型中的数字位置
		永远不要根据枚举的序数导出与它关联的值，而是将它保存在一个实例域中
	第三十二条：用EnumSet代替位域
	第三十三条：用EnumMap代替序数索引
		最好不要用序数来索引数组，而要使用EnumMap
	第三十四条：用接口模拟可伸缩的枚举
		虽然无法编写可扩展的枚举类型，却可以通过编写接
		口以及实现该接口的基础枚举类型，对它进行模拟
	第三十五条：注解优先于命名模式
		元注解：
			@Retention
			@Target
		既然有了注解，就完全没有必要使用命名模式了
	第三十六条：坚持使用override注解
	第三十七条：用标记接口定义类型
		标记接口是没有包含方法声明的接口
			标记接口定义的类型是由被标记类的实例实现的，标记注解则没有定义这样的类型
			标记接口可以被更加精确的进行锁定
		如果标记应用到任何程序元素而不是类或者接口，需用注解
		如果标记只应用给类和接口，应该使用标记接口
第六章：方法
	第三十八条：检查参数的有效性
		对于共有方法，要用Javadoc的@throw标签在文档中说明违反参数值限制时抛出的异常
		非共有方法通常应该使用断言（assertion）来检查它们的参数
	第三十九条：必要时进行保护性拷贝
		对于构造器的每个可变参数进行保护性拷贝（defensive copy）是必要的
		注意保护性拷贝是在检查参数有效性之前进行的，并且有效性检查针对拷贝之后的对象，而不是针对原始的对象。
		对于参数类型可以被不可信任方子类化的参数，请不要使用clone方法进行保护性拷贝
	第四十条：谨慎设计方法签名
		谨慎的选择方法名称
		不要过于追求提供便利的方法
		避免过长的参数列表
		
		对于参数类型，要优先使用接口而不是类
		对于Boolean类型，要优先使用两个元素的枚举类型
	第四十一条：慎用重载
	第四十二条：慎用可变参数	
	第四十三条：返回零长度的数组或者集合，而不是null
		返回类型为数组或者集合的方法没理由返回null，而不是返回一个零长度的数组或者集合
	第四十四条：为所有导出的API元素编写文档注释
		为了正确的编写API文档，必须在每个被导出的类、接口、构造器、方法和域声明之前增加一个文档注释
		方法的文档注释应该简洁的描述出它与客户端之间的约定
		为枚举类型编写文档时，要确保在文档中说明常量
		为注解类型编写文档时，要确保在文档中说明所有成员
第七章：通用程序设计
	第四十五条：将局部变量的作用域最小化
		要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明
		几乎每个局部变量的声明都应该包含一个初始化表达式
	第四十六条：for-each循环优先于传统的for循环
		遍历数组和集合  	实现了Iterable接口的对象
		下列三种情况无法使用for-each循环
			1.过滤-如果需要遍历集合，并删除选定的元素，就需要使用显示的迭代器，以便可以调用它的remove方法
			2.转换-如果需要遍历列表或者数组，并取代它部分或者全部的元素值，
				就需要列表迭代器或者数组索引，以便设定元素值
			3.平行迭代-如果需要并行的遍历多个集合，就需要显示的控制迭代器或者索引变量，
				以便所有迭代器或者索引变量都可以得到同步前移。
	第四十七条：了解和使用类库
	第四十八条：如果需要精确的答案，请避免使用float和double
		使用	BigDecimal（超过18位）
			int（9-18位）
			long（不超过9位）
	第四十九条：基本类型优先于装箱基本类型
		基本类型和装箱基本类型之间的区别
			1.基本类型只有值，装箱基本类型型具有与它们的值不同的同一性
			2.基本类型只有功能完备的值，装箱基本类型除了对应基本类型的所有功能值之外，还有一个非功能值：null
			3.基本类型通常比装箱基本类型更省时间和空间
		对装箱基本类型运用==操作符几乎总是错误的
		当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱
		装箱基本类型的用处
			1.作为集合中的元素、键和值
			2.在参数化类型中，必须使用装箱基本类型作为类型参数
			3.在进行反射的方法调用时，必须使用装箱基本类型
	第五十条：如果其他类型更合适，尽量避免使用字符串
		字符串不适合代替其他的值类型
		字符串不适合代替枚举类型
		字符串不适合代替聚集类型
		字符串也不适合代替能力表
	第五十一条：当心字符串连接的性能
		字符串连接符（"+"）
		为连接n个字符串而重复地使用字符串连接操作符，需要n的平方级时间
		为了获得可以接受的性能，请使用StringBuilder代替String
	第五十二条：通过接口引用对象
		如果有合适的接口类型存在，对于参数、返回值、变量和域来说，应该使用接口类型进行声明
	第五十三条：接口优先于反射机制
		反射
			丧失了编译时类型检查的好处
			执行反射访问所需要的代码非常笨拙和冗长
			性能损失
		通常，普通应用程序在运行时不应该以反射方式访问对象
	第五十四条：谨慎的使用本地方法
		java native interface(JNI)
		使用本地方法来提高性能的做法不值得提倡	
	第五十五条：谨慎的进行优化
		要努力编写好的程序而不是快的程序
		努力避免那些限制性能的设计决策			
		要考虑API设计决策的性能后果
		为获得好的性能而对API进行包装，是一种非常不好的想法
		在每次试图做优化之前和之后，要对性能进行测量
		性能剖析器
	第五十六条:遵守普遍的命名习惯
第八章：异常
	第五十七条：只针对异常的情况才使用异常
		异常应该只用于异常的情况下:它们永远不应该用于正常的控制流
		设计良好的API不应该强迫它的客户端为了正常的控制流而使用异常
	第五十八条:对可恢复的情况使用受检异常，对编程错误使用运行时异常
		受检的异常（checked exception）
			如果期望调用者能够适当的恢复，对于这种情况就应该使用受检的异常
		运行时异常（run-time exception）
			用运行时异常来表明编程错误
			你实现的所有未受检的抛出结构都应该是RuntimeException的子类
		错误（error）
	第五十九条：避免不必要的使用受检的异常
	第六十条：优先使用标准的异常
	第六十一条：抛出与抽象对应的异常
		更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常--异常转义
		尽管异常转译与不加选择的从低层传递异常的做法相比有所改进，但是它也不能被滥用
		如果不能阻止或者处理来自更低层的异常，一般的做法是使用异常转译
	第六十二条：每个方法抛出的异常都要有文档	
		始终要单独的声明受检的异常，并且利用javadoc的@throw标记，准确的记录下抛出的每个异常条件
	第六十三条：在细节消息中包含能捕获失败的信息	
		为了捕获失败，异常的细节信息应该包含所有“对该异常有贡献”的参数和域的值。
	第六十四条：努力使失败保持原子性
		一般而言，失败的方法调用应该使对象保持在被调用之前的状态
	第六十五条:不要忽略异常
		空的catch块会使异常达不到应有的目的
		catch块应该包含一条说明，解释为什么可以忽略这个异常
第九章：并发
	第六十六条：同步访问共享的可变数据
		为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的
		（synchronize）
		将可变数据限制在单个线程中
		当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步
	第六十七条：避免过度同步
		为了避免活性失败和安全性失败，在一个被同步的方法或者代码块中，永远不要放弃对客户端的控制
		通常，应该在同步区域内做尽可能少的工作。
		为了避免死锁和数据破坏，千万不要从同步区域内部调用外来方法，要尽量限制同步区域内部的工作量
	第六十八条：executor和task优先于线程
	第六十九条：并发工具优先于wait和notify
		concurrent中更高级的工具分为三类：
			Executor Framework
			并发集合Concurrent Collection
				ConcurrentConcurrentHashMap
			同步器Synchronizer：一些使线程能够等待另一个线程的对象，允许它们协调动作
				常用：CountDownLatch、Semaphore
				不常用：CyclicBarrier、Exchanger
		对于维护wait和notify的老系统
			始终应该使用wait循环模式来调用wait方法，永远不要在循环之外调用wait方法
			一般情况下，应该使用notifyAll，而不是使用notify。如果使用notify，要小心，以确保程序灵活性
	第七十条：线程安全性的文档化
		一个类为了可被多个线程安全的使用，必须在文档中清楚的说明它所支持的线程安全性级别
		不可变的
			String，Long、BigInteger
		无条件的线程安全
			Random，ConcurrentHashMap
		有条件的线程安全
			collection.synchronized，iterator
		非线程安全
			ArrayList，HashMap
		线程对立的
		
		有条件的线程安全类必须在文档中指明哪个方法调用序列需要外部同步，以及在执行这些序列的时候要获得那把锁
		无条件的线程安全类应该使用私有锁对象来替代同步的方法，这样可以防止客户端程序和子类不同步干扰，让你能够在后续的版本中灵活的并发控制采用更加复杂的方法
	第七十一条：慎用延时初始化
		在大多数情况下，正常初始化要优先于延时初始化
		如果利用延时化来破坏初始化的循环，就要使用同步访问方法
		如果出于性能的考虑而需要对静态域使用延时初始化，就使用lazy initialization holder class模式
			private static class FileHolder{
				static final FieldType field=computeFieldValue();
			}
			static FieldType getField(){ return FileHolder.field;}
		如果出于性能的考虑而需要对实例域使用延时初始化，就使用双重检查模式
			private volatile FieldType field;
			FieldType getField(){
				FieldType result=field;
				if(result==null){ 	//first check(no locking)
					synchronized(this){
						result=field;
						if(result==null)	//second check(with locking)
							field=result=computeFieldValue();
					}
				}
				return result;
			}
		单重检查模式
			private volatile FieldType field;
			private FieldType getField(){
				FieldType result=field;
				if(result==null){
					field=result=computeFieldValue();
				}
				return result;
			}
		
		对于实例域，就使用双重检查模式；对于静态域，则使用lazy initialization holder class模式；对于可以接受重复初始化的实例域，可以考虑使用单重检查模式
	第七十二条：不要依赖于线程调度器
		任何依赖线程调度器来达到正确性或者性能要求的程序，很有可能都是不可移植的
		线程优先级是java平台上最不可移植的特征了
		不要依赖Thread.yield或者线程优先级
		线程优先级可以用来提高一个已经能够正常工作的程序的服务质量，但永远不应该用来修正一个原本不能工作的程序
	第七十三条：避免使用线程组
		因为线程组已经过时了，所以实际上根本没有必要修正
第十章：序列化
	第七十四条：谨慎的实现Serializable接口
		实现Serializable接口而付出的最大代价是，一旦一个类被发布，就大大降低了“改变这个类的实现”的灵活性
			流的唯一标识符：序列版本UID
		实现Serializable的第二个代价是，它增加了出现Bug和安全漏洞的可能性
		实现Serializable的第三个代价是，随着类发行新的版本，相关的测试负担也增加了
		
		为了继承而设计的类应尽可能少的去实现Serializable接口，用户的接口也应该尽可能少的继承Serializable接口
		内部类不应该实现Serializable
	第七十五条：考虑使用自定义的序列化形式
		即使你确定默认序列化的形式是合适的，通常必须提供一个readObject方法以保证约束关系和安全
			defaultWriteObject,defaultReadObject
	第七十六条：保护性的编写readObject方法
		当一个对象被反序列化的时候，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，就必须要做保护性拷贝，这是非常重要的
		保护性拷贝在有效性检查之前进行
		readObject方法不可以调用可被覆盖的方法，无论是直接调用还是间接调用都不可以
		
		编写readObject方法的指导方针
		1.对于对象引用域必须保持为私有的类，要保护性的拷贝这些域中的每个对象。不可变类的可变组件就属于这一类别
		2.对于任何约束条件，如果检查失败，则抛出一个InvalidObjectException异常。这些检查动作应该跟在所有的保护性拷贝之后
		3.如果整个对象图在被序列化之后必须进行验证，就应该使用ObjectInputValidation接口
		4.无论是直接方式还是间接方式，都不要调用类中任何可被覆盖的方法
	第七十七条：对于实例控制，枚举类型优先于readResolve
		readResolve特性允许你用readObject创建的实例代替另一个实例
		如果依赖readResolve进行实例控制，带有对象引用类型的所有实例域则都必须声明为transient的
		readResolve的可访问性很重要
	第七十八条：考虑用序列化代理代替序列化实例
		在一个不能被客户端扩展的类上编写readObject或者writeObject方法的时候，就应该考虑使用序列化代理模式
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		